<!DOCTYPE html>
<html lang="en">
<head>
  <title>Railway Track Health Visualization</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #1a1a1a; }
    
    /* --- HUD LABEL STYLING --- */
    .segment-label {
      background: rgba(0, 0, 0, 0.7); /* Dark semi-transparent background */
      border: 1px solid #444;
      border-left: 3px solid #00ff00; /* Default Accent */
      color: #fff;
      font-family: 'Courier New', Courier, monospace; /* Tech font */
      font-size: 12px;
      padding: 8px;
      border-radius: 4px;
      pointer-events: none; /* Let clicks pass through */
      white-space: pre; /* Preserve formatting */
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      margin-top: -20px; /* Offset to float above */
    }

    .key { color: #888; }
    .val { color: #4fc3f7; font-weight: bold; }
  </style>
</head>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/"
  }
}
</script>

<body>

<script type="module">
  import * as THREE from "three";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  // Import the CSS2D Renderer for HTML labels
  import { CSS2DRenderer, CSS2DObject } from "three/addons/renderers/CSS2DRenderer.js";

  // --- 1. SETUP ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x1a1a1a); 
  scene.fog = new THREE.Fog(0x1a1a1a, 5, 25); 

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(5, 5, 8);

  // WebGL Renderer (The 3D world)
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  // CSS2D Renderer (The Text Labels)
  const labelRenderer = new CSS2DRenderer();
  labelRenderer.setSize(window.innerWidth, window.innerHeight);
  labelRenderer.domElement.style.position = 'absolute';
  labelRenderer.domElement.style.top = '0px';
  // This allows us to still control the 3D scene underneath the labels
  labelRenderer.domElement.style.pointerEvents = 'none'; 
  document.body.appendChild(labelRenderer.domElement);

  // Controls (attached to the labelRenderer so they work through the text layers)
  // Note: We attach controls to labelRenderer because it is physically "on top"
  const controls = new OrbitControls(camera, labelRenderer.domElement);
  controls.enableDamping = true; 
  controls.target.set(0, 0, -2);
  // Re-enable pointer events for controls
  labelRenderer.domElement.style.pointerEvents = 'auto'; 

  // --- 2. LIGHTING ---
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); 
  scene.add(ambientLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
  dirLight.position.set(5, 10, 5);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  scene.add(dirLight);

  // --- 3. FLOOR ---
  const planeGeo = new THREE.PlaneGeometry(100, 100);
  const planeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8, metalness: 0.2 });
  const plane = new THREE.Mesh(planeGeo, planeMat);
  plane.rotation.x = -Math.PI / 2;
  plane.position.y = -0.1; 
  plane.receiveShadow = true;
  scene.add(plane);

  // --- 4. DATA LOGIC ---
  const overlayGroup = new THREE.Group();
  scene.add(overlayGroup);

  const loader = new GLTFLoader();
  loader.load("./models/railway_track.glb", (gltf) => {
      const trackModel = gltf.scene;
      trackModel.scale.set(1.5, 1.5, 1.5);
      trackModel.position.set(0, 0, 0);
      trackModel.traverse((node) => {
          if (node.isMesh) { node.castShadow = true; node.receiveShadow = true; }
      });
      scene.add(trackModel);
      trackModel.add(overlayGroup); 
  });

  function getPriorityColorHex(p) {
    if (p === 1) return '#00ff00'; // Green CSS
    if (p === 2) return '#ffff00'; // Yellow CSS
    if (p === 3) return '#ffa500'; // Orange CSS
    return '#ff0000'; // Red CSS
  }

  function getPriorityColorThree(p) {
     return new THREE.Color(getPriorityColorHex(p));
  }

  const activeOverlays = [];
    async function loadData() {
    let segments = [];
    
    // Try to get data from localStorage first
    try {
      const stored = localStorage.getItem('trackAssessmentData');
      if (stored) {
        segments = JSON.parse(stored);
        console.log('Loaded assessment data from dashboard:', segments);
      }
    } catch (e) {
      console.error('Error reading assessment data:', e);
    }

    // Fallback to API if no local data
    if (segments.length === 0) {
      console.warn("No dashboard data found, fetching from API fallback");
      const response = await fetch("http://127.0.0.1:8000/assess/network", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          segments: [
            { segment_id: 1, features: [0.32, 1.8, 28.5, 1.01, 420] },
            { segment_id: 2, features: [0.48, 3.9, 52.2, 0.97, 610] },
            { segment_id: 3, features: [0.71, 6.4, 78.1, 1.08, 890] }
          ]
        })
      });

      if (response.ok) {
        const data = await response.json();
        segments = data.segments;
      } else {
        console.error("API Error:", await response.text());
        return;
      }
    }

    const spacing = 2.5;
    const total = segments.length;

    segments.forEach((seg, i) => {
      // --- A. 3D Overlay ---
      const threeColor = getPriorityColorThree(seg.priority);

      const geo = new THREE.BoxGeometry(2.2, 0.15, 1.5);
      const mat = new THREE.MeshStandardMaterial({
        color: threeColor,
        emissive: threeColor,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.4,
        roughness: 0.1,
        metalness: 0.1
      });

      const overlay = new THREE.Mesh(geo, mat);

      const zPos = (i - (total - 1) / 2) * spacing;
      overlay.position.set(0, 0.15, zPos);

      overlayGroup.add(overlay);
      activeOverlays.push({ mesh: overlay, baseOpacity: 0.4 });

      // --- B. HTML Label ---
      const div = document.createElement("div");
      div.className = "segment-label";
      div.style.borderLeftColor = getPriorityColorHex(seg.priority);

      const f = seg.features ?? [];
      div.innerHTML = `
  <span class="key">ID:</span> <span class="val">${seg.segment_id}</span>
  <span class="key">Fault:</span> <span class="val">${seg.fault.replace(/_/g, ' ')}</span>
  <span class="key">Priority:</span> <span class="val">${seg.priority}</span>
  <span class="key">Conf:</span> <span class="val">${(seg.confidence * 100).toFixed(1)}%</span>
  <span class="key">Action:</span> <span class="val">${seg.action}</span>
  `;

      const label = new CSS2DObject(div);
      label.position.set(0, 1.5, 0);
      overlay.add(label);
    });
  }


  loadData();

  // --- 5. ANIMATION LOOP ---
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();
    
    controls.update();

    // Pulse Animation
    activeOverlays.forEach((obj, index) => {
        const pulse = (Math.sin(time * 2 + index) + 1) * 0.15; 
        obj.mesh.material.opacity = obj.baseOpacity + pulse;
        obj.mesh.material.emissiveIntensity = 0.5 + (pulse * 2);
    });

    // Render BOTH scenes
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
  }
  
  // Handle Resize
  window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
  });

  animate();
</script>

</body>
</html>